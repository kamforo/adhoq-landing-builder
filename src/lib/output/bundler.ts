import archiver from 'archiver';
import { Writable } from 'stream';
import type { GenerationResult } from '@/types';

/**
 * Create a ZIP archive of generated variations
 */
export async function createZipBundle(
  variations: GenerationResult[],
  projectName: string
): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    const chunks: Buffer[] = [];
    const archive = archiver('zip', { zlib: { level: 9 } });

    // Collect chunks
    archive.on('data', (chunk) => chunks.push(chunk));
    archive.on('end', () => resolve(Buffer.concat(chunks)));
    archive.on('error', reject);

    // Add each variation
    for (const variation of variations) {
      const folderPrefix = variations.length > 1
        ? `variation-${variation.variationNumber}/`
        : '';

      // Add HTML
      archive.append(variation.html, {
        name: `${folderPrefix}index.html`,
      });

      // Add changes log
      if (variation.changes.length > 0) {
        const changesMarkdown = formatChangesAsMarkdown(variation);
        archive.append(changesMarkdown, {
          name: `${folderPrefix}changes.md`,
        });
      }

      // Add assets with base64 content
      for (const asset of variation.assets) {
        if (asset.content) {
          const content = typeof asset.content === 'string'
            ? Buffer.from(asset.content, 'base64')
            : asset.content;

          archive.append(content, {
            name: `${folderPrefix}assets/${asset.newPath}`,
          });
        }
      }
    }

    // Add project README
    const readme = formatProjectReadme(variations, projectName);
    archive.append(readme, { name: 'README.md' });

    // Finalize
    archive.finalize();
  });
}

/**
 * Format changes as markdown
 */
function formatChangesAsMarkdown(variation: GenerationResult): string {
  const lines = [
    `# Changes Log - Variation ${variation.variationNumber}`,
    '',
    `Generated: ${new Date(variation.generatedAt).toLocaleString()}`,
    '',
  ];

  // Group changes by type
  const groups: Record<string, typeof variation.changes> = {};
  for (const change of variation.changes) {
    if (!groups[change.type]) groups[change.type] = [];
    groups[change.type].push(change);
  }

  for (const [type, changes] of Object.entries(groups)) {
    lines.push(`## ${type.charAt(0).toUpperCase() + type.slice(1)} Changes`);
    lines.push('');

    for (const change of changes) {
      lines.push(`### ${change.reason}`);
      lines.push('');
      lines.push(`**Selector:** \`${change.selector}\``);
      lines.push('');
      lines.push('**Original:**');
      lines.push('```');
      lines.push(change.originalValue.substring(0, 500));
      lines.push('```');
      lines.push('');
      lines.push('**New:**');
      lines.push('```');
      lines.push(change.newValue.substring(0, 500));
      lines.push('```');
      lines.push('');
    }
  }

  return lines.join('\n');
}

/**
 * Format project README
 */
function formatProjectReadme(
  variations: GenerationResult[],
  projectName: string
): string {
  return `# ${projectName}

Generated by Adhoq Landing Page Builder

## Contents

${variations.map((v, i) => {
  const folder = variations.length > 1 ? `variation-${v.variationNumber}/` : '';
  return `- **Variation ${v.variationNumber}**: \`${folder}index.html\` (${v.changes.length} changes)`;
}).join('\n')}

## Quick Start

1. Upload the contents of a variation folder to your web server
2. If using placeholders, replace them with actual images
3. Update any links or tracking codes as needed
4. Test on multiple devices before going live

## Files

Each variation contains:
- \`index.html\` - The main landing page
- \`changes.md\` - Detailed log of all modifications
- \`assets/\` - Any downloaded assets (if available)

## Notes

- Original URLs are preserved in \`data-original-*\` attributes
- Placeholder images can be found by searching for "placehold.co"
- All tracking codes have \`data-original-*\` attributes if modified

---

Generated: ${new Date().toLocaleString()}
Powered by Adhoq Landing Page Builder
`;
}

/**
 * Create a single HTML file with inlined assets
 */
export async function createSingleHtmlFile(
  variation: GenerationResult
): Promise<string> {
  // For now, just return the HTML as-is
  // In the future, this could inline CSS and convert images to base64
  return variation.html;
}
